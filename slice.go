package main

import "fmt"

// 1
// Какой будет результат выполнения приложения?
func main() {
	a := []string{"a", "b", "c"}
	b := a[1:2]
	b[0] = "q"
	fmt.Println(a)
}

/* Результатом работы данного кода будет [a q c]. Так получится потому, что b = элементы слайса а с 1 по 2,
то есть b = [b, c], а потом меняем элемент с индексом 0 слайса b на q.
Суть в том, что до тех пор, пока не произошло переполнение слайса а, и а, и b ссылаются на один массив в памяти.
*/

// 2
// Что выведет код и почему?
func mod(a []int) {
	a = append(a, 125)
	for i := range a {
		a[i] = 5
	}
	fmt.Println(a)
}
func main() {
	sl := []int{1, 2, 3, 4, 5}
	mod(sl)
	fmt.Println(sl)
}

/* Данный код сначала выведет 5 5 5 5 5 5, а потом 1 2 3 4 5.
Это произойдет потому, что в функции mod в слайс добавляется шестой элемент, а потом все элементы заменяются на 5.
А вывод функции main остается 1 2 3 4 5 из-за того, что при добавлении нового элемента в массив его вместимость
превысила максимум и произошла  (в памяти создался новый массив с большей вместимостью и все
действия в функции проводились уже с ним)
*/

// 3
// Что выведет данный код?
func mod(a []int) {
	for i := range a {
		a[i] = 5
	}
	fmt.Println(a)
}
func main() {
	sl := make([]int, 4, 8)
	sl[0] = 1
	sl[1] = 2
	sl[2] = 3
	sl[3] = 5
	mod(sl)
	fmt.Println(sl)
}

/*
Данный код является противоположной ситуацией к предыдущему. В данном случае вывод будет [5 5 5 5] и [5 5 5 5].
Так произойдет потому что в этот раз была задана вместимость слайса 8 и переполнения не происходило,
след-но все изменения в функции mod происходят на том же массиве, что и в функции main.
*/
